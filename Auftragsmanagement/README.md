# Auftragsmanagement
Teilnehmer: Jan Schröder, Festim Sokoli, Oliver Heis, Daryan Segler, Lennert Wollmann


## Einleitung
Im Rahmen unseres Projektes haben wir uns dazu entschieden, eine Anwendung zur Unterstützung des Auftragsmanagements zu entwickeln. Die Grundidee hinter dem Projekt stammt aus einem anderen Modul, aus diesem Semester. Dabei soll das Auftragsmanagement einige Funktionen abdecken. Es soll möglich sein, sich einzuloggen und anhand verschiedener Rollen unterschiedliche Rechte zu erhalten. Somit kann ein Vertriebsmitarbeiter andere Funktionen nutzen als ein Administrator. Außerdem ist eine zentrale Idee des Projektes typische CRUD (Create, Read, Update, Delete) Aufgaben abzudecken. Dabei sollen unter anderem Artikel- und Kundendaten angelegt, gepflegt, gelöscht und aktualisiert werden können. Dieselbe Funktionsweise gilt für Aufträge und Auftragspositionen. Ein weiteres zentrales Feature, ist die Preisberechnung auf Basis der Menge bestellter Produkte, wobei auch Preisnachlässe wie Rabatte oder Skonti berücksichtigt werden. Bei der Auswahl der Technologie haben wir uns bewusst dagegen entschieden, Flutter und Dart zu verwenden, da einige Personen aus unserem Team bereits Erfahrungen mit dem in unserem Projekt verwendeten Java/Spring und Angular Framework haben. Somit erschien es uns leichte, die Fähigkeiten, die wir haben zu verwenden, anstatt neue Fähigkeiten von Grund auf zu erlernen. In unserem Projekt verwenden wir Java/Spring für das Backend, also um prinzipiell die Funktion des Projektes zu gewährleisten. Im Frontend verwenden wir Angular um das UI (User Interface) darzustellen. Als Versionskontrolle haben wir GitHub verwendet, in welchem wir Issues erstellt haben, um den Überblick darüber zu behalten, was innerhalb des Projektes zutun ist und um Ideen für beispielsweise Features festzuhalten. Zur besseren Organisation und effizienteren Umsetzung haben wir unser Team in zwei Gruppen aufgeteilt: Frontend und Backend. Zwei Teammitglieder arbeiteten am Backend, drei am Frontend. Diese Aufteilung erfolgte, weil wir eingeschätzt haben, dass die Arbeit am Frontend umfangreicher und zeitintensiver ist, bspw. durch UI-Design, Benutzerinteraktionen, Styling und die Abstimmung mit den Backend zur Datenanbindung. Gleichzeitig haben wir regelmäßig gemeinsam besprochen, wie Schnittstellen aussehen sollen, um die Integration reibungslos zu gestalten.
## Backend
Im Backend haben wir eine feste Struktur verwendet, um eine strukturierte Arbeitsweise zu gewährleisten. Dazu haben wir einzelne Klassen für Entitäten, Controller und Services erstellt, um diese voneinander zu kapseln.
Alle Service Klassen zu den jeweiligen Entitäten haben dabei dieselben CRUD-Methoden, welche in unserem Fall folgende Methoden umfassen: erstelle Entität mit Attributen, erhalte alle Entitäten dieses Typs, erhalte alle Entitäten anhand dieser ID, lösche eine Entität anhand der ID und aktualisiere eine Entität anhand ihrer ID. Der Controller einer Entität wird verwendet, um mit dem Frontend zu kommunizieren und ruft dabei im immer eine der oben genannten Service Methoden auf. Der Controller dient als Zwischenebene um nicht direkt auf den Service zuzugreifen, sondern eine Art Abstraktionsebene zu schaffen.
### Datenbank
Als Datenbank verwenden wir die H2-Datenbank. H2 ist eine in Java geschriebene relationale Datenbank, die besonders häufig in Entwicklungs- und Testumgebungen verwendet wird. Sie ist einfach zu konfigurieren und lässt sich einfach in Java Anwendungen integrieren. Wir verwenden H2 aus verschiedensten Gründen. Einer dieser Gründe ist, dass kein Setup notwendig ist und H2 mit Start der Anwendung läuft. Somit muss kein externer Datenbankserver installiert werden. Außerdem hat H2 eine Webkonsole, welche eine Oberfläche hat, mit welcher wir auch SQL-Abfragen gegen die Datenbank ausführen können, um bspw. Daten entgegen zu prüfen. Des Weiteren ist sie JPA (Java Persistance API) kompatibel, und lässt sich in Spring Boot leicht integrieren.
### Entitäten
Im Kontext unseres Projektes dienen Entitäten dazu, die zentralen Datenmodelle des Auftragsmanagements abzubilden. Sie sind in der Regel Java Klassen, welche durch die Annotation @Entity gekennzeichnet werden und werden direkt mit einer Datenbanktabelle verknüpft.
Innerhalb der Entitäten wurden Konstruktoren, sowie Getter und Setter Methoden durch Keywords wie „@Data“, „@AllArgsConstructor“ oder „@NoArgsConstructor“ ersetzt. Diese Annotationen stammen aus der „Lombok“ Bibliothek und ersetzen diese Methoden, um den Code übersichtlicher zu gestalten und dem Entwickler die Arbeit zu erleichtern, da er weniger Code schreiben muss und diese „Snippets“ verwenden kann.
#### Auftrag
Eine dieser Entitäten ist beispielsweise die Entität „Auftrag“, welche einen Auftrag abbilden soll, welcher aus einer ID, einem Namen, einer Beschreibung, einem Gesamtwert und einer Gesamtmenge besteht. Mit „Gesamtwert“ ist der summierte Wert aller Artikel innerhalb eines Auftrages gemeint, während „Gesamtmenge“ die gesamte Anzahl an Artikeln innerhalb eines Auftrages beschreibt. Jeder Auftrag hat außerdem eine „ManyToOne“ Beziehung zu einem Kunden, da ein Auftrag einem Kunden Objekt zugewiesen ist, aber ein Kunden Objekt mehrere Aufträge erstellen kann. Des Weiteren besitzt jeder Auftrag eine Auftragsposition, welche einem gewissen Auftrag einen beliebigen Artikel mit einer beliebigen Menge zuordnet, sodass wir innerhalb unseres Auftrages verschiedenste Artikel Objekte mit einer vom Nutzer festgelegten Menge haben. Somit dient Auftragsposition als Bindeglied zwischen Artikel und Auftrag, um Artikel einem oder mehreren Aufträgen zuzuordnen.
Die Entität „Auftrag“ enthält das Entwurfsmuster des Observers (Beobachter). Die zentrale Idee eines Observers ist es Änderungen an einem Objekt an von diesem Objekt abhängige Strukturen zu geben. In diesen Anwendungsfall wurde der Observer verwendet, um Veränderungen an einem Objekt in der Konsole auszugeben. Somit wird beispielsweise bei der Erzeugung eines Objektes in der Konsole ausgegeben, dass ein neues Objekt erzeugt wurde. Gleichzeitig gilt die Ausgabe in der Konsole auch für andere Veränderungen an einem Objekt wie beispielsweise das Löschen oder Aktualisieren eines Objektes. Somit wird der Observer in dem Anwendungsfall des Auftrags rein, als Logging Werkzeug verwendet, um Logs zur Erzeugung von Aufträgen zu erstellen. Das nächste im Auftrag verwendete Entwurfsmuster ist der Iterator. Dieses Muster ermöglicht es uns, sowohl strukturiert als auch kontrolliert durch eine Liste oder Sammlung von Elementen zu iterieren, unabhängig davon, wie die Datenstruktur genau aussieht. In unserem Fall wird der Iterator in der Klasse AuftragIterator verwendet. Der Iterator erlaubt es uns, eine Liste von Auftrag-Objekten schrittweisen zu durchlaufen, ohne direkt mit der Liste arbeiten zu müssen. Dadurch wird die Kapselung gestärkt und die Iteration ist durch die spezielle Klasse AuftragIterator klar und wiederverwendbar gestaltet. Der Vorteil des Iterators liegt darin, dass die Iteration von der Datenhaltung getrennt wird. Dadurch ist der Zugriff auf die Aufträge einfacher und lesbarer. Das letzte Entwurfsmuster im Auftrag ist der State. Das State Muster kapselt zustandsabhängiges Verhalten in eigene Klassen und ermöglicht dem Objekt (in unserem Fall der Auftrag), sein Verhalten abhängig von seinem Zustand zu ändern, ohne dass die Logik in vielen Kontrollstrukturen wie z.B. if/else oder switch versteckt ist. Bei unserer Umsetzung hat die Entität Auftrag ein Attribut auftragStatus vom Typ AuftragStatus, welches das aktuell Verhalten des Auftrags kapselt. AuftragStatus ist ein Interface, welches von mehreren Klassen implementiert wird: NeuState, InBearbeitungState und AbgeschlossenState. Diese Klassen implementieren jeweils das Verhalten für Methoden wie bearbeiten() oder abschliessen() abhängig vom Status. Dabei bietet State auch Vorteile wie Übersichtlichkeit und Erweiterbarkeit, da wir, anstatt viele Bedingungen zu prüfen, einfach das passende Objekt mit dem passenden Verhalten verwenden. Wenn wir bspw. einen neuen Status wie „Storniert“ hinzufügen, dann muss man nur eine neue Klasse erstellen, ohne den bestehenden Code zu verändern.

#### Notiz
Eine weitere Entität in unserem Projekt ist die Notiz. Diese Entität folgt der Idee, dass beispielsweise auf einer Messe oder anderem Event beispielsweise ein Vertriebler einen potenziellen Kunden oder Interessenten kennenlernt und sich somit Notizen zu dieser Person macht. Um diese Notizen im Nachhinein nachvollziehbar zu machen, haben wir der Entität eine ID zur eindeutigen Identifizierung, einen Zeitstempel, um zu wissen, von wann die Notiz stammt und einen Text, um beispielsweise das Gespräch aufzuzeichnen als Attribut hinzuzufügt. Jede Notiz ist mit einem Kunden Objekt verbunden, wobei jeder Kunde eine beliebige Anzahl an Notizen zugewiesen werden kann. Somit könnte der Nutzer auch im Nachhinein weitere Notizen zu Gesprächen mit dem Kunden hinzufügen. Die Notiz enthält zwei Entwurfsmuster. Das erste Entwurfsmuster ist der Command (Kommando). In der Notiz wird der Command ähnlich wie der Observer im Auftrag verwendet, und zwar, um Logs zu erstellen. Dabei ist die Idee des Commands, dass jede Aktion, welche an der Notiz vorgenommen wird, wie z.B. das Erstellen oder Löschen einer Notiz, als Befehl gekapselt und ausgeführt wird. Dabei wird gleichzeitig ein entsprechender Log-Eintrag erzeugt. Dadurch wird jede Änderung nachvollziehbar dokumentiert, was die Nachvollziehbarkeit des Systems erhöht. Das zweite in der Notiz verwendete Entwurfsmuster ist die Factory (Fabrik). Das Ziel dieses Musters ist es, die Erstellung von Objekten zu kapseln und damit den Erstellungsprozess zu vereinfachen. In unserem Fall übernimmt die Notiz-Factory die Aufgabe der Erstellung von Notiz-Objekten. Somit werden Notiz-Objekte nicht durch den Aufruf eines Konstruktors erzeugt, sondern durch den Aufruf einer Methode.
#### Artikel
Die Artikel Entität repräsentiert einen Artikel, der einem Auftrag zugewiesen werden kann. Die Grundidee dahinter ist, dass ein Artikel ein Produkt oder eine Leistung darstellt, welche im Rahmen eines Auftrags, beispielsweise von einem Kunden benötigt wird. Ein Artikel besteht ausfolgenden Attributen: einer eindeutigen ID, einem Namen, einer Beschreibung und einem Preis. Ähnlich wie der Auftrag ist der Artikel mit der Entität Auftragsposition verbunden, sodass die Auftragsposition als Bindeglied fungieren kann. Innerhalb des Artikels wurde das Entwurfsmuster Builder (Erbauer) implementiert. Der Builder gewährleistet eine flexible und schrittweise Erstellung von Objekten. Der Builder ermöglicht es uns einen Artikel flexibel zu gestalten, sodass wir einzelne Teile des Artikels auslassen können, bspw. die Beschreibung eines Artikels. So lässt sich z.B. ein Artikel auch ohne Beschreibung erzeugen, wobei diese später ergänzt werden kann, oder bewusst weggelassen werden kann. Im Artikel wurde auch ein zweites Entwurfsmuster verwendet, und zwar das DTO (Data Transfer Object). Ein DTO dient dazu, Daten zwischen den einzelnen Schichten der Anwendung auszutauschen, ohne dabei Geschäftslogik zu enthalten. Im Gegensatz zu der Entität Artikel, welche möglicherweise Beziehungen und zusätzliche Logik enthält, stellt das ArtikelDTO nur die relevanten Felder bereit, welche für den Datenaustausch, z.B. mit dem Frontend benötigt werden. In unserem Fall verwenden wir den Namen, die Beschreibung und den Preis des Artikels. Zusätzlich verwendet das DTO Validierungsannotationen der Lombok Bibliothek (@NotBlank), um sicherzustellen, dass sowohl der Name, als auch der Preis nicht leer sind. Damit hilft das DTO auch dabei, zu validieren, bevor die Daten an die Geschäftslogik weitergegeben werden.
#### AuftragPositionen
Die Entität AuftragPositionen stellt eine Auftragsposition dar und dient als Verbindung zwischen einem Auftrag und einem oder mehreren Artikeln. In einem klassischen Auftragsmanagementsystem besteht ein Auftrag häufig aus mehreren Positionen, wobei jede Position für einen bestimmten Artikel mit einer bestimmten Menge steht.
Die AuftragPosition besteht auf folgenden Attributen: einer eindeutigen ID, einem Auftrag (Referenz auf den zugehörigen Auftrag), einem Artikel (Referenz auf den zugehörigen Artikel) und Menge, welche angibt, wie viele Einheiten eines Artikels in dieser Position enthalten sind. Diese Entität ist essenziell, um die Zuordnung von mehreren Artikeln zu einem Auftrag zu ermöglichen. Gleichzeitig erlaubt sie die Angabe der Menge je Artikel, was wichtig für die spätere Preisberechnung sowie für Rabatt und Skonto ist. 
### Unabhängige Entwurfsmuster
Ein weiteres in unserem Projekt eingesetztes Entwurfsmuster ist die Strategy. Dieses Muster ermöglicht es, verschiedene Verhaltensweisen austauschbar zu definieren, ohne die Klasse zu verändern, die sie verwendet. In unserem Fall verwenden wir das Strategy Muster zur Umsetzung verschiedener Rabattlogiken. Die Klasse MengenRabatt ist eine konkrete Implementierung der RabattStrategy Schnittstelle. Diese Strategy berechnet Rabatte basierend auf der Anzahl der Artikel, die in einem Auftrag enthalten sind, also ein Mengenrabatt. Bei weniger als 10 Artikeln wird kein Rabatt gewährt. Bei 10 bis 24 Artikeln wird ein Rabatt von 5% auf den Gesamtpreis angewandt. Bei 25 Artikeln oder mehr gibt es einen 10% Rabatt auf den Gesamtpreis. Die Verwendung der Strategy uns Flexibilität, da wir einfach neue Rabattstrategien für z.B. Stammkunden ergänzen können. Außerdem trennen wir die Rabattberechnung von der Hauptberechnungslogik, sodass zuerst der Gesamtwert eines Auftrags berechnet wird, und erst im Anschluss der Rabatt. Dadurch wird der Rabatt nicht fehlerhaft auf einzelne Artikel berechnet sondern auf den Gesamtwert. 
### Testing
Während der Entwicklung unserer Anwendung haben wir darauf geachtet, dass alle Funktionen korrekt arbeiten und ob die Schnittstellen erwartungsgemäß reagieren/antworten. Dafür haben wir kein automatisiertes Testing mit Unit- oder Intergrationstests verwendet, sondern haben die Anwendung manuell getestet. Im Backend haben wir dazu primär Insomnia verwendet, oder Extensions in der jeweiligen IDE. Mithilfe von Insomnia konnten wir HTTP-Anfragen gezielt an usnere REST Schnittstellen senden, um beispielsweise neue Artikel oder Aufträge zu erstellen, bestehende Einträge zu aktualisieren oder gezielt Fehler zu provozieren, um diese zu beheben. Dadurch konnten wir testen, wie das System auf fehlerhafte Eingaben reagiert. Auch komplexere Vorgänge wie die Berechnung von Rabatten oder das Setzen von Zuständen (z.B. „in Bearbeitung“, „abgeschlossen“) wurden so manuell überprüft. Dieses manuelle Testverfahren hat uns ermöglicht, Fehler frühzeitig zu erkennen und die Korrekte Funktionalität der wichtigsten Backend Features zu gewährleisten, auch ohne automatisierte Testumgebung.
